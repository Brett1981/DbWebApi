# DbWebApi

### What is it?

With DbWebApi you can access SQL Server or Oracle package stored procedure like 
`http://BaseUrl/fully_qualified_name_of_stored_procedure/mediatype` from any http client, get the results as JSON, XML, CSV, Excel xlsx, JSONP, or any text generated by Razor dynamic templating. For examples,

**SQL Server**:
* `http://dbwebapi.dev.com/sqldev/TestDb.dbo.your_sp/json`
* `http://dbwebapi.dev.com/sqldev/TestDb.dbo.your_sp/jsonp?callback=jsFunc1`
* `http://dbwebapi.dev.com/sqldev/TestDb.dbo.your_sp/xml`
* `http://dbwebapi.dev.com/sqldev/TestDb.dbo.your_sp/xlsx?filename=Rpt2015`
* `http://dbwebapi.dev.com/sqldev/TestDb.dbo.your_sp/csv?resultset=0&filename=Rpt2015`
* `http://dbwebapi.dev.com/sqldev/TestDb.dbo.your_sp/razor?RazorTemplate=outTemplateSpParameter`

**Oracle**:
* `http://dbwebapi.dev.com/oradev/test_schema.prj_package.your_sp/json`
* `http://dbwebapi.dev.com/oradev/test_schema.prj_package.your_sp/jsonp?callback=jsFunc1`
* `http://dbwebapi.dev.com/oradev/test_schema.prj_package.your_sp/xml`
* `http://dbwebapi.dev.com/oradev/test_schema.prj_package.your_sp/xlsx?filename=Rpt2015`
* `http://dbwebapi.dev.com/oradev/test_schema.prj_package.your_sp/csv?resultset=0&filename=Rpt2015`
* `http://dbwebapi.dev.com/sqldev/test_schema.prj_package.your_sp/razor?RazorTemplate=outTemplateSpParameter`

***

DbWebApi is a .Net library that implement an entirely generic Web API for data-driven applications clients to call database (Oracle & SQL Server) stored procedures or functions out-of-box without any configuration or extra coding, the http response JSON or XML will have all Result Sets, Output Parameters and Return Value. For cross-domain access, client can request JSONP response. If client request a CSV format (accept: text/csv), the http response will transmit one result set as a CSV stream for large amounts of data. DbWebApi also supports xlsx (Excel 2007/2010) format response for multiple resultsets (each resultset presents as an Excel worksheet). While being regarded as a proxy service, DbWebApi reflects in two directions: Data Access Proxy and Media Format Proxy.

In other words, DbWebApi provides an alternative way to implement your Web APIs by implementing some stored procedures or functions in database. The DbWebApi will expose these stored procedures or functions as Web APIs straight away.

### What are the benefits of DbWebApi?

- The underlying tenet:  
Less coding, less configuration, less deployment, less maintenance.  
The conciseness of using DbWebApi is down-to-earth for hands-on developers, to access database stored procedures or functions is completely coding-free and configuration-free. Don't need to explicitly specify any metadata about database objects (such as parameters type, size, direction... or columns attributes) by coding or configuration, don't need to write any controller for handling new data models from database, don't need to write any method for calling new stored procedures or functions ... No more dazzling _The Emperor's New Services(Clothes)_ to test(fitting), deploy or maintain.
- In data-driven applications area, there are a large number of scenarios without substantial logic in data access web services, however they wasted a lot of our efforts on very boring data moving coding or configurations, we've had enough of it. Since now on, most of thus repetitive works can be dumped onto DbWebApi.
- DbWebApi can coexist within your existing ASP.NET Web API, as a supplementary service to reduce new boring manual works for most common of application scenarios.

## Usage

#### ApiController:
``` CSharp
using System.Net.Http;
using System.Web.Http;
using System.Collections.Generic;
using DataBooster.DbWebApi;

namespace SampleDbWebApi.Controllers
{
    public class DbWebApiController : ApiController
    {
        [DbWebApiAuthorize]
        [AcceptVerbs("GET", "POST", "PUT", "DELETE", "OPTIONS")]
        public HttpResponseMessage Execute(string sp, Dictionary<string, object> parameters)
        {
            return this.ExecuteDbApi(sp, Request.GatherInputParameters(parameters));
        }
    }
}
```
That's it!  
ExecuteDbApi is the extension method to ApiController.
``` CSharp
public static HttpResponseMessage ExecuteDbApi(this ApiController apiController,
                                               string sp, IDictionary<string, object> parameters)
// sp:         Specifies the fully qualified name of database stored procedure or function
// parameters: Specifies required input-parameters as name-value pairs
```

#### Web.config  
"DataBooster.DbWebApi.MainConnection" is the only one configuration item needs to be customized:
``` Xml
<connectionStrings>
  <add name="DataBooster.DbWebApi.MainConnection" providerName="System.Data.SqlClient" connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=SAMPLEDB;Integrated Security=SSPI" />
</connectionStrings>
```

#### HTTP Request  
##### Url:  
As registered in your WebApiConfig Routes (e.g. http://BaseUrl/Your.StoredProcedure.FullyQualifiedName)  
##### Input Parameters:  
Only required input-parameters of the stored procedure/function need to be specified in your request body as JSON format (Content-Type: application/json). Don't put parameter prefix ('@' or ':') in the JSON body.  
For example, a SQL Server Stored Procedure:  
``` SQL
ALTER PROCEDURE dbo.prj_GetRule
    @inRuleDate  datetime,
    @inRuleId    int,
    @inWeight    float(6) = 0.1,
    @outRuleDesc varchar(256) = NULL OUTPUT
AS  ...
```
The request JSON should like:  
``` JSON
{
    "inRuleDate":"2015-02-03T00:00:00Z",
    "inRuleId":108
}
```
Parameter names are case-insensitive.

##### Accept Response MediaType:  
1. JSON (default)  
    Specify in request header:  
    Accept: application/json  
    or  
    Accept: text/json  
    or specify in query string: ?format=json  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule?format=json)  
    or specify in UriPathExtension which depends on your url routing  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule/json)  

2. JSONP  
    QueryString must contain **callback** parameter _(the name can be configured)_  
    and (  
    Specify in request header:  
    Accept: text/javascript  
    or  
    Accept: application/javascript  
    or  
    Accept: application/json-p  
    or specify in query string: ?format=jsonp  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule?format=jsonp)  
    or specify in UriPathExtension which depends on your url routing  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule/jsonp)  
    )  

3. XML  
    Specify in request header:  
    Accept: application/xml  
    or  
    Accept: text/xml  
    or specify in query string: ?format=xml  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule?format=xml)  
    or specify in UriPathExtension which depends on your url routing  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule/xml)  

4. xlsx (Excel 2007/2010)  
    Specify in request header:  
    Accept: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet  
    or  
    Accept: application/ms-excel  
    or  
    Accept: application/xlsx  
    or specify in query string: ?format=xlsx  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule?format=xlsx)  
    or specify in UriPathExtension which depends on your url routing  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule/xlsx)  
    Notes: Since xlsx content presents as an attachment, so you can specify a filename for convenience by query string: FileName=\[save_as\] (default: \[save_as\].xlsx).  

5. CSV
    Specify in request header:  
    Accept: text/csv  
    or specify in query string: ?format=csv  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule?format=csv)  
    or specify in UriPathExtension which depends on your url routing  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule/csv)  
    Notes: CSV response will only return the first (or one specified zero indexed result set in query string: ResultSet=i) result set if your stored procedure has multiple result sets. Since CSV content presents as an attachment, so you can specify a filename for convenience by query string: FileName=\[save_as\] (default: \[save_as\].csv).  

6. Razor Templating    
    Specify in request header:  
    Accept: text/razor  
    or  
    Accept: application/razor  
    or specify in query string: ?format=razor  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule?format=razor)  
    or specify in UriPathExtension which depends on your url routing  
       (e.g. http://BaseUrl/YourDatabase.dbo.prj_GetRule/razor)  
    Notes: To send a Razor request, the template text must be provided in a conventionalized parameter {RazorTemplate=} in either json body of post request or query string of get request, if the template text is a output parameter name of the stored procedure, the string content of that output parameter will be used as the actual template text. Two optional parameters: {RazorEncoding=Raw|Html} _(default is Raw)_ and {RazorLanguage=CSharp|VisualBasic} _(default is CSharp)_.   
    Model's Data: Inside Razor template, the **@Model** directive represents your strored procedure's result data. _(E.g.  @Model.OutputParameters.outSomeThing - is the value of output parameter outSomeThing, @Model.ResultSets[0][0].SomeProperty - is the value of Some_Property column of the first row of the first resultset)_  
 
7. Other MediaTypes  
    To support new MediaType, you can:

* Control in low level (DbDataReader and writeStream), you can create a new class that implements the interface **IFormatPlug**, and register it in your HttpConfiguration. Just like following CSV and xlsx did:
``` CSharp
    public static void RegisterDbWebApi(this HttpConfiguration config)
    {
        config.AddFormatPlug(new CsvFormatPlug());
        config.AddFormatPlug(new XlsxFormatPlug());
    }
```
* Control in high level (start point: StoredProcedureResponse), you can create a new XyzMediaTypeFormatter class as [classical tutorial](http://www.asp.net/web-api/overview/formats-and-model-binding/media-formatters) shows.
  

#### Response data internal structure
``` CSharp
    public class StoredProcedureResponse
    {
        public List<List<BindableDynamicObject>> ResultSets { get; set; }
        public BindableDynamicObject OutputParameters { get; set; }
        public object ReturnValue { get; set; }
    }
```

#### Response body formats  
##### application/json, text/json  
    Sample:  
``` JSON
{
  "ResultSets":
  [
    [
      {"COL_1":"2015-02-03T00:00:00","COL_2":3.14159,"COL_3":"Hello World1","COL_4":null, "COL_5":0},
      {"COL_1":"2015-02-02T00:00:00","COL_2":3.14159,"COL_3":null,"COL_4":1234567.800099, "COL_5":1},
      {"COL_1":"2015-02-01T00:00:00","COL_2":3.14159,"COL_3":"Hello World3","COL_4":null, "COL_5":2},
      {"COL_1":"2015-01-31T00:00:00","COL_2":3.14159,"COL_3":null,"COL_4":9876541.230091, "COL_5":3}
    ],
    [
      {"COL_A":100,"COL_B":"fooA","COL_C":0},
      {"COL_A":200,"COL_B":"fooB","COL_C":null},
      {"COL_A":300,"COL_B":"fooC","COL_C":1}
    ],
    [
       {"NOTE":"Test1 for the third result set"},
       {"NOTE":"Test2 for the third result set"}
    ]
  ],
  "OutputParameters":
  {
    "outRuleDesc":"This is a test output parameter value.",
    "outSumTotal":888888.88,
    "outRC1":null
  },
  "ReturnValue":0
}
```

##### application/xml, text/xml  
    Sample:
``` XML
<ResponseRoot xmlns:x="http://www.w3.org/2001/XMLSchema" xmlns:i="http://www.w3.org/2001/XMLSchema-instance" xmlns="http://schemas.datacontract.org/2004/07/DbParallel.DataAccess">
  <OutputParameters>
    <outRuleDesc i:type="x:string" xmlns="">This is a test output parameter value.</outRuleDesc>
    <outSumTotal i:type="x:decimal" xmlns="">888888.88</outSumTotal>
    <outRC1 i:nil="true" xmlns="" />
  </OutputParameters>
  <ResultSets>
    <ArrayOfBindableDynamicObject>
      <BindableDynamicObject>
        <COL_1 i:type="x:dateTime" xmlns="">2015-02-03T00:00:00</COL_1>
        <COL_2 i:type="x:decimal" xmlns="">3.14159</COL_2>
        <COL_3 i:type="x:string" xmlns="">Hello World1</COL_3>
        <COL_4 i:nil="true" xmlns=""/>
        <COL_5 i:type="x:int" xmlns="">0</COL_5>
      </BindableDynamicObject>
      <BindableDynamicObject>
        <COL_1 i:type="x:dateTime" xmlns="">2015-02-02T00:00:00</COL_1>
        <COL_2 i:type="x:decimal" xmlns="">3.14159</COL_2>
        <COL_3 i:nil="true" xmlns=""/>
        <COL_4 i:type="x:decimal" xmlns="">1234567.800099</COL_4>
        <COL_5 i:type="x:int" xmlns="">1</COL_5>
      </BindableDynamicObject>
      <BindableDynamicObject>
        <COL_1 i:type="x:dateTime" xmlns="">2015-02-01T00:00:00</COL_1>
        <COL_2 i:type="x:decimal" xmlns="">3.14159</COL_2>
        <COL_3 i:type="x:string" xmlns="">Hello World3</COL_3>
        <COL_4 i:nil="true" xmlns=""/>
        <COL_5 i:type="x:int" xmlns="">2</COL_5>
      </BindableDynamicObject>
      <BindableDynamicObject>
        <COL_1 i:type="x:dateTime" xmlns="">2015-01-31T00:00:00</COL_1>
        <COL_2 i:type="x:decimal" xmlns="">3.14159</COL_2>
        <COL_3 i:nil="true" xmlns=""/>
        <COL_4 i:type="x:decimal" xmlns="">9876541.230091</COL_4>
        <COL_5 i:type="x:int" xmlns="">3</COL_5>
      </BindableDynamicObject>
    </ArrayOfBindableDynamicObject>
    <ArrayOfBindableDynamicObject>
      <BindableDynamicObject>
        <COL_A i:type="x:int" xmlns="">100</COL_A>
        <COL_B i:type="x:string" xmlns="">fooA</COL_B>
        <COL_C i:type="x:int" xmlns="">0</COL_C>
      </BindableDynamicObject>
      <BindableDynamicObject>
        <COL_A i:type="x:int" xmlns="">200</COL_A>
        <COL_B i:type="x:string" xmlns="">fooB</COL_B>
        <COL_C i:nil="true" xmlns=""/>
      </BindableDynamicObject>
      <BindableDynamicObject>
        <COL_A i:type="x:int" xmlns="">300</COL_A>
        <COL_B i:type="x:string" xmlns="">fooC</COL_B>
        <COL_C i:type="x:int" xmlns="">1</COL_C>
      </BindableDynamicObject>
    </ArrayOfBindableDynamicObject>
    <ArrayOfBindableDynamicObject>
      <BindableDynamicObject>
        <NOTE i:type="x:string" xmlns="">Test1 for the third result set</NOTE>
      </BindableDynamicObject>
      <BindableDynamicObject>
        <NOTE i:type="x:string" xmlns="">Test2 for the third result set</NOTE>
      </BindableDynamicObject>
    </ArrayOfBindableDynamicObject>
  </ResultSets>
  <ReturnValue i:nil="true" />
</ResponseRoot>
```

##### text/csv  
    Sample:
``` CSV
COL_1,COL_2,COL_3,COL_4,COL_5
2015-02-03,3.14159,Hello World1,,0
2015-02-02,3.14159,,1234567.800099,1
2015-02-01,3.14159,Hello World3,,2
2015-01-31,3.14159,,9876541.230091,3
```

Notes:  
> JSON, XML and xlsx respones are constructed completely in Web API server before sending to the client, so you might  encounter OutOfMemoryException if the client wants to receive huge amounts of data. However, JSON can be sufficient in most application scenarios with its simplicity. And after all, process data as close to where the data physically resides as possible, this is a basic principle of big data processing. (i.e. Simplifying the complexity as early as possible.)  

>For most of Web applications, the final data are for human eyes to read.

>For some systems integration, CSV format is also widely used for data filling. It's mostly waste of human resources to design such SSIS packages one by one, and to maintain such encumbrances for ever. It's time for machine to do such mechanical process, let DbWebApi serve as the machine. No more mechanical designs, no more packages, no more configurations, no more deployments and no more maintenances. Let artificial complexities, dust to dust, nothing to nothing!

>CSV respone emerges as text stream pushing to the client, it just use very little memory in Web API server to push a few text lines as long as their CSV rows have been constructed, so on and so forth, until all complete. So the server's memory is not a limitation of how many records can be handled.

####  Property Naming Convention
Database side may use a different naming convention other than .NET side or JavaScript side. For example, most Oracle works use underscores naming convention, like above output examples, from a .NET or JavaScript point of view, they could look really ugly. So DbWebApi provides 2 + _None_ built-in naming convention resolvers:
- PropertyNamingConvention.None
- PropertyNamingConvention.PascalCase
- PropertyNamingConvention.CamelCase

You can set the DefaultPropertyNamingConvention globally in your WebApiConfig:
``` CSharp
public static class WebApiConfig
{
    public static void Register(HttpConfiguration config)
    {
        ....
        DbWebApiOptions.DefaultPropertyNamingConvention =
            PropertyNamingConvention.PascalCase;
    }
}
```
You can also specify the output Property Naming Convention in Uri Query String of each individual request:
- NamingCase=N (or None) ---------- As it is in database 
- NamingCase=P (or Pascal) -------- PascalCase
- NamingCase=C (or Camel) -------- CamelCase

If you don't specify the NamingCase in later request, the global set before will back into effect.


### Exceptions
For JSON, XML and xlsx responses, detail exception will be encapsulated into HttpResponseMessage with HTTP 500 error status if the Web API service encounters any problems. For the verbosity of errors to show in client side, it depends on your IncludeErrorDetailPolicy in HttpConfiguration. However, because CSV respone uses a push stream, the client side will always receive a HTTP 200 OK header without Content-Length field. If the server side encounter any exception subsequently, it would simply interrupt the http connection and the client would get a Receive Failure without any detail exception message.

### Permission Control
The example project shows using an authorization filter [DbWebApiAuthorize] to restrict which user can execute which stored procedure, that will integrate with your own implementation of permissions checking.
``` CSharp
    public class MyDbWebApiAuthorization : IDbWebApiAuthorization
    {
        public bool IsAuthorized(string userName, string storedProcedure)
        {
            // TO DO, to implementate your own authorization logic
            return true;	// If allow permission
            return false;	// If deny permission
        }
    }
```

### UserName
Recording current username is a common auditing requirement. Since the Web API never trust any self-identify username sent from client request data. So if a stored procedure requires the username as a parameter, the Web API should always replace that parameter sent from the client (or add that parameter if a client didn't send it) by the server side authentication. Any practical way as long as you think it's simple enough can be apply in your Web API implementation. For examples,
* Make a naming convention for this special parameter in database within your enterprise, then the Web API always set (replace/add) this special parameter before pass the whole input parameters dictionary to ExecuteDbApi extension method. It won't hurt anything, because in its low level DataBooster will match stored procedure parameter names with the input parameters dictionary that you pass in, and discard non-matched parameters.
* Or in a traditional way, create separate Controllers for those stored procedures individually, in their internal implementation set current username and then call the ExecuteDbApi extension method. :(
* Or in a centralized table, register that which stored procedures which parameter require current UserName input, so that in the Web API can know when it need to replace/add which input parameter.
* etc.

### Performance  
* Connection Pool Tuning  
Facing with concurrent requests from different clients in different business contexts. DbWebApi server opens a new database connection per request. All requests are using the same connection string. So the Connection Pool Tuning is very important to the performance of the whole responsiveness.

* Load Balancing  
As a completely generic web service, DbWebApi makes the distributed deployment much simpler, every nodes in the distributed environment are equivalent. It is easier to apply any of today's existing web server load balance techniques.

* For front-end applications and systems integration  
As a Web API, the target clients are still front-end applications mainly, plus some data formats transform for systems integration convenience.  
The performance overhead of each extra wrapper of network service _(wrap one web service on top of another web service, and another one ... fussily)_ is always very expensive. For efficient custom data services development, it is recommended to use [DataBooster Library - Extension to ADO.NET Data Provider](http://databooster.codeplex.com/) directly for high-performance database access.  
  

## Clients
#### .Net Client  
[DbWebApi Client .Net Library](http://www.nuget.org/packages/DataBooster.DbWebApi.Client.Net) can be used to simplify the client call. See following sample:
``` CSharp
using DataBooster.DbWebApi.Client;
```
``` CSharp
DbWebApiClient client = new DbWebApiClient("http://dbwebapi.dev.com/oradev/");

//  client.HttpMethod = HttpMethod.Get;    // Default is POST

// Synchronous call. If need asynchronous call, please use ExecAsJsonAsync(..) instead.
DbWebApiResponse data = client.ExecAsJson("test_schema.prj_package.foo",
    new {
        inDate = new DateTime(2015, 3, 16)
        //, ... other input parameters, if any.
    });

// You can either consume JObject[] (LINQ to JSON) directly or cast to your strong-type business class as below:
IEnumerable<MyStrongTypeCls> strongTypeObjs = data.ResultSets[0].Select(j => j.ToObject<MyStrongTypeCls>());
```
If you just need the response content stream (E.g. CSV, Excel xlsx or generated text) to be stored as a file or transfer forward to somewhere else on the network, see below example, replacing ExecAsJson() by ExecRawAsync(), then [write the HTTP content to a stream](https://msdn.microsoft.com/en-us/library/hh138076.aspx) dicectly.
``` CSharp
....
var task = client.ExecRawAsync("test_schema.prj_package.foo",
    new {
        inDate = new DateTime(2015, 3, 16)
        //, ... other input parameters, if any.
    });
using (FileStream file = File.Create(...))
{
    task.Result.Content.CopyToAsync(file).Wait();
}
```

By default, the DbWebApiClient uses Windows authentication for the convenience of intranet usage scenarios. Please see its constructor overrides for other options.

All Exec... methods will use HTTP POST method by default. You can change the default behavior to HTTP GET if need be. (as the comment line in above example code)

#### JavaScript Client  
You can use jQuery.ajax easily to call the Web API, or you can use [DbWebApi Client JavaScript Library](http://www.nuget.org/packages/DataBooster.DbWebApi.Client.JS) to reduce repetitive coding.  
    Sample:
``` javascript
    <script src="Scripts/jquery-2.1.3.js" type="text/javascript"></script>
    <script src="Scripts/dbwebapi_client-1.0.8-alpha.js" type="text/javascript"></script>
```
``` javascript
<script type="text/javascript">
    ....
    $.postDb('http://dbwebapi.dev.com/oradev/test_schema.prj_package.foo',
             '{"inDate":"2015-03-10T00:00:00.000Z"}',
             function (data) {
                 // Bind data.ResultSets[0] with some contorls,
                 // or iterate through each JSON object in data.
             });
    ....
</script>
```
The second argument of $.postDb - inputJson can be either a JSON string or a plain object. If it's a plain object, it will be converted by JSON.stringify before sending to the server. Below sample is equivalent to above sample.
``` javascript
    ....
    var input = {
        inDate: $.utcDate(2015,03,10)
    };
    $.postDb('http://dbwebapi.dev.com/oradev/test_schema.prj_package.foo',
             input,
             function (data) {
                 ....
             });
    ....
```
If there is no input parameter to pass to the server, please put _**null**_ in the second argument.  
By default, the $.postDb sets the withCredentials property of the internal xhrFields object to true so it will pass the user credentials with cross-domain requests.  
As the name implies, $.postDb uses HTTP POST to send a request;  
Alternatively, $.getDb can be used for HTTP GET if need be. All input parameters are encapsulated into a special query string, and appended to the url for GET-requests.

For the moment, the Client JavaScript Library (prerelease version 1.0.8-alpha) was tested on IE9 only.

##### Cross-domain  
![](https://github.com/DataBooster/DbWebApi/blob/master/Doc/Images/ie9-cors.png)
For intranet scenarios, browsers settings can be managed by your system administrator centralizedly. However, for internet scenarios, we can't just assume that end users will set their browsers to allow cross-domain calls.  

###### JSONP for now (Added: Server Lib v1.2.4, Client JS v1.0.8-alpha) 
JSONP is a practicable way _(although it seems a little rascal)_ to solve the cross-domain access puzzle before CORS (Cross-Origin Resource Sharing) is supported by all popular browsers.  
Below example is a JSONP approach of above example,
``` javascript
    ....
    var input = {
        inDate: $.utcDate(2015,03,10)
    };
    $.jsonpDb('http://dbwebapi.dev.com/oradev/test_schema.prj_package.foo',
             input,
             function (data) {
                 ....
             });
    ....
```
The server side:
``` CSharp
    config.RegisterDbWebApi();
```
will include JSONP support by default. If you don't want to support JSONP, you can remove the JsonpMediaTypeFormatter from the config.Formatters collection after that.  


###### CORS later  
Currently, the example server project in this repository supports _(untested)_ CORS in server side. However, IE's security setting _(Access data sources across domains)_ still disables CORS requests by default.
``` javascript
```

#### PowerShell Client  
In Windows PowerShell 3.0 or higher, [Invoke-RestMethod](https://technet.microsoft.com/en-us/library/hh849971.aspx) cmdlet is readily available. See following sample:
``` PowerShell
$inpms = @{inDate = [DateTime]"2015-03-16"};
$response = Invoke-RestMethod -UseDefaultCredentials -Method Post -Uri "http://dbwebapi.dev.com/oradev/test_schema.prj_package.foo" -Body (ConvertTo-Json $inpms) -ContentType "application/json"
```
$response contains all the result data. In Powershell ISE, IntelliSense can show you all its member properties. If you want to save the response body stream (such as CSV or Excel xlsx) into a specified output file, please just use -OutFile parameter,
``` PowerShell
Invoke-RestMethod -UseDefaultCredentials -Method Post -Uri "http://dbwebapi.dev.com/oradev/test_schema.prj_package.foo" -Body (ConvertTo-Json $inpms) -ContentType "application/json" -OutFile "\\somewhere\somepath\filename.ext"
```

PowerShell is true powerful to do more solid work with less coding. Especially for back office system-integration applications, heterogeneous techniques across different systems can be leveraged by PowerShell's interoperability with consistent pipeline mechanism. It's also extremely handy to use PowerShell as a test/debug tool. With PowerShell, you would even didn't want to use Fiddler for Web API testing any more. In PowerShell, the data is visualized and extremely flexible to be quickly modified interactively.  

``` PowerShell
```


## NuGet
#### Server side
There are 4 NuGet packages for 4 differenct versions of ADO.NET providers:
- [DbWebApi for SQL Server](http://www.nuget.org/packages/DataBooster.DbWebApi.SqlServer)
- [DbWebApi for Oracle (use ODP.NET Managed Driver)](http://www.nuget.org/packages/DataBooster.DbWebApi.Oracle.Managed)
- [DbWebApi for Oracle (use ODP.NET Provider)](http://www.nuget.org/packages/DataBooster.DbWebApi.Oracle.ODP)
- [DbWebApi for Oracle (use DataDirect Provider)](http://www.nuget.org/packages/DataBooster.DbWebApi.Oracle.DataDirect)

For-Oracle versions always contain the support for SQL Server. To switch from Oracle to SQL Server, simply change the providerName and connectionString of connectionStrings "DataBooster.DbWebApi.MainConnection" in your web.config.  
To switch above from one NuGet package to another NuGet Package, simply uninstall one and install another from NuGet Package Manager.
#### Clients
- [DbWebApi Client .Net Library](http://www.nuget.org/packages/DataBooster.DbWebApi.Client.Net)
- [DbWebApi Client JavaScript Library](http://www.nuget.org/packages/DataBooster.DbWebApi.Client.JS)

## Examples

Please refer to example project - MyDbWebApi in https://github.com/DataBooster/DbWebApi/tree/master/Examples/MyDbWebApi

If you are only interested in having your trial server setup quickly, you can download the released server side samples from https://dbwebapi.codeplex.com/releases/view/614695 simplicity.

The example project requires Visual Studio 2010 at lowest with ASP.NET MVC 4 installed.
Hopefully, base on the example, it's easier to customize your own DbWebApi server.